## 03. 코드에서 나는 악취

### 3.1 기이한 이름
함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 `무슨 일을 하고 어떻게 사용해야 하는지 명확하게 알 수 있도록` 신경써서 이름을 지어야 한다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

### 3.2 중복 코드
똑같은 코드 구조가 여러 곳에서 반복된다면 `하나로 통합하여` 더 나은 프로그램을 만들 수 있다.

### 3.3 긴 함수
오랜 기간 잘 활용되는 함수는 대체로 길이가 짧으며 함수가 길수록 이해하기 어려워진다. 짧은 이름을 짓기 위해 함수를 최대한 쪼개야한다.

### 3.4 긴 매개변수 목록
매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

### 3.5 전역 데이터
전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 매커니즘이 없는 절대 지양해야할 문제이다. <font color="red">절대 사용하지 말 것!</font>

### 3.6 가변 데이터
데이터가 변경 가능할 경우 그에 따른 예상치 못한 부가효과가 일어날 확률이 매우 높다. 때문에 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 원래 데이터는 그대로 둔 채 변경하려는 값에 해당하는 `복사본을 반환한다`는 개념을 기본으로 삼고 있다. 불변성이 주는 장점을 위해 변수는 최대한 불변을 지향하자.

### 3.7 뒤엉킨 변경
이 문제는 `단일 책임 원칙SRP`이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다. 하나의 기능에는 하나의 책임만 가능하도록 기능을 세분화해야한다.

### 3.8 산탄총 수술
둬엉킨 변경과 비슷하면서도 정반대이다. 코드를 변경할 때 자잘하게 변경해야할 부분이 많다면 이는 하나의 기능이 여러 곳에 분산되어 있다는 것을 뜻한다. 해당 부분을 찾아 하나로 자 모아 주면 여기저기 찾아 헤맬 필요가 없어진다.

### 3.9 기능 편애
모듈의 `응집도`에 관한 부분으로, 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다. 이 문제는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 `다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때` 발생한다.

### 3.10 데이터 뭉치
연관있는 데이터는 뭉쳐서 `객체화` 시키자!

### 3.11 기본형 집착
기초 타입을 정의하는 꺼려하고 기본 숫자나 문자열로 변수 및 코드를 다루게 되면 예기치 못한 상황이 생긴다. 직접 객체로 바꿔주거나 서브클래스로 바꿔주자.

### 3.12 반복되는 switch문
중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야하기 때문이다. 이럴 때 `다형성`은 반복된 switch문 대신 사용할 수 있는 훌륭한 무기가 된다.

### 3.13 반복문
반복문은 `파이프라인`으로 바꾸자! 

### 3.14 성의 없는 요소
기존 프로그램 요소, 리팩터링을 거치며 메서드가 하나뿐인 클래스 등 여러 빈약한 요소는 깔끔히 정리하자.

### 3.15 추측성 일반화
나중에 필요할거란 생각으로 미래지향적 코드를 미리 작성해둔다면 오히려 치울 쓰레기만 늘리는 셈이다. 코드는 지금 당장 사용할 것을 위주로 탄탄히 작성해나가자.

### 3.16 임시 필드
특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 이런 형태는 추후 오해를 살 수 있으니 제거하는게 좋다.

### 3.17 메시지 체인
이 문제는 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 물론 고쳐야하지만 메서드 체인을 무조건 나쁘게 생각하는 것은 옳지 않다. (디미터 법칙, 기차충돌 참고)

### 3.18 중개자
객체의 캡슐화로 인해 과도하게 위임하는 과정을 거칠 때엔 실제로 기능하는 객체를 `직접` 연결해야 할 지도 모른다.

### 3.19 내부자 거래
모듈 사이의 데이터 거래가 많으면 결합도가 높아진다. 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다. 

### 3.20 거대한 클래스
한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다. 이와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다. 어쨌든 비대한 것은 명시적인 것과 거리가 멀다. 쪼개어 보기 좋게 만들어주자.

### 3.21 서로 다른 인터페이스의 대안 클래스들
클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단, 교체하려면 `인터페이스가 같아야 한다`. 인터페이스가 같아질 때까지 필요한 동작들을 클래스에 추가하고 중복코드가 생기면 추출한다.

### 3.22 데이터 클래스
데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 그저 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다. 무조건 게터/세터를 사용하지 말고 불변한 항목은 필드 자체를 공개하는 등 필요한 부분만 이용하자.

### 3.23 상속 포기
서브 클래스는 부모로부터 메서드와 데이터를 물려받는다. 이것을 원치 않을 경우 서브 클래스를 통해 뺄 수 있지만 이보다는 `추상 클래스`를 사용하는 것이 좋다.

### 3.24 주석
주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해보자. 상당량의 주석은 코드가 제대로 작성되었을 경우 필요없을 때가 많다. 주석은 앞으로 수정해야 할 부분, 현재 진행 상황, 뭘 할지 모를 때 등 `문제가 해결되면 해당 주석을 걷어낼 경우 사용하는 것`이다.
