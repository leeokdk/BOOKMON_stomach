## 02. 리팩터링 원칙
### 2.1 리팩터링 정의
- `명사` 소프트웨어의 겉보기 동작은 그대로 워한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.
- `동사` 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.
- `재구성restructuring` 코드베이스를 정리하거나 구조를 바꾸는 모든 작업. 단순히 코드를 고치는 것은 리팩터링과는 다르다.
- **리팩터링 전과 후의 코드는 똑같이 동작해야 한다(사용자관점).**
- 리팩터링은 성능 최적화와 비슷하지만 성능 최적화는 속도 개선의 목적을 갖고 있어 코드가 더 어렵게 바뀔 수도 있다.


> ? 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다?
> 굳이 왜 버그의 상태까지 남아있어야 하는지.. 고치면 더 좋은게 아닌가? 심지어 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다는데 그러면 그냥 다 수정하는 쪽이 낫지 않나? 크리티컬한 에러야 수정하는데 오래 걸리면 아무래도 리팩터링의 의미가 퇴색되므로 둔다고 하지만..


### 2.2 두 개의 모자
개발의 목적에 따른 두 개의 모자 구분
- `기능 추가`: 이 모자를 쓸 때엔 기존 코드는 절대 건드리지 않고 새로운 기능을 추가하는데 전념한다. 진척도는 테스트를 추가해서 통과하는지 확인한다.
- `리팩터링`: 이 모자를 쓸 때엔 기능 추가는 절대 하지 않고 오로지 코드 재구성에만 전념한다. 부득이 인터페이스를 변경할 때만 기존 테스트를 수정한다.

> ? 새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 그러면 잠시 모자를 바꿔 쓰고 리팩터링 한다. 
> 이러면 그냥 그때그때 기능 추가하고 리팩터링 한다는 말 같은데.. 말장난인가?

### 2.3 리팩터링하는 이유
- 리팩터링하면 `소프트웨어 설계`가 좋아진다.
    - 산재하는 중복 코드를 줄여 코드량이 줄면 이해해야 하는 코드량이 줄어들고 코드를 수정할 때 실수할 확률이 줄어들며 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.
- 리팩터링하면 소프트웨어를 `이해`하기 쉬워진다.
    - 타인 혹은 미래의 나 자신이 프로그래밍한 코드를 파악할 시간을 줄이는 것은 중요하다. 만든 코드를 완전히 잃어버려도 코드 파악이 쉽다면 아주 이상적.
- 리팩터링하면 `버그`를 쉽게 찾을 수 있다.
    - 코드를 이해하기 쉽다는 말과 일맥상통. 코드의 구조가 명확해지면 버그가 선명하게 드러난다. 굳이 눈에 힘주고 찾을 필요가 없어진다.
- 리팩터링하면 `프로그래밍 속도`를 높일 수 있다.
    - 일반적으로 리팩터링은 품질과 직결되고 속도와는 반비례한다고 생각할 수 있다. 하지만 역설적으로 건강한 코드는 결국 디버깅하기 쉽고 코드를 만날 가능성을 줄이고 새 기능을 쉽게 반영할 수 있어 거시적인 시점에서 속도가 빠르다고 할 수 있다.
    - 처음부터 완벽한 설계란 있을 수 없다. 설계 후 만들어진 코드는 부패하지만 리팩터링을 하면 설계를 발전시킬 수 있는 이점도 존재한다.

### 2.4 언제 리팩터링해야 할까?
> `삼진 리팩터링`: 비슷한 일을 세 번째 하게 되면 리팩터링하라.

- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
    - 리팩터링하기 가장 좋은 시점은 코드베이스에 `기능을 새로 추가하기 직전`이다.
    - 코드를 살펴보고 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
    - 예시1. 리터럴 값 몇 개가 방해되어 함수를 복제하여 값을 수정하는 대신 함수에 필요한 매개변수를 지정해서 호출할 수 있도록 함수를 매개변수화하였다.
    - 예시2. 오류를 일으키는 코드가 세 곳에 복제되어 있다면 우선 한 곳으로 합쳐 작업한다.
    - 예시3. 질의 코드에 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 줄일 수 있다.
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
    - 코드를 파악할 때 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아보자. 그 후 리팩터링하여 이해한 것을 코드에 반영해둔다.
    - 어떤 역할을 하는지 이해된 변수와 함수의 이름을 명확하게 바꿔주고, 긴 함수를 잘게 나눠 그 역할을 세분화하고 명료성을 높인다.
    - 깔끔하게 정리된 코드는 마치 잘 닦인 창문처럼 처음에는 보이지 않던 설계가 눈에 들어오게 한다.
- 쓰레기 줍기 리팩터링
    - 코드를 파악하던 중에 목적과 별개로 고쳐야할게 눈에 들어올 수 있다. 이 때는 잘 타협하여 행동해야 한다.
    - 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음 하던 일을 끝내고 나서 처리한다.
    - 리팩터링은 각각의 작은 단계가 코드를 해치지 않기 때문에 안정적으로 작업하여 코드를 깔끔하게 만들 수 있다.
- 계획된 리팩터링과 수시로 하는 리팩터링
    - 어차피 좋은 코드는 굉장히 많은 리팩토링을 겪어야 한다. 기회가 될 때마다 작은 단위로 리팩토링을 하는게 좋다.
    - 지저분한 코드 뿐만 아니라 잘 작성된 코드 또한 리팩토링의 대상이 된다. 단 좋은 코드가 리팩토링하기 더 쉬울 뿐이다.
    - 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
    - 피치못하여 리팩토링이 꽤 지났을 경우 시간을 내어 리팩토링에 투자하는 것도 나쁘지는 않다. 하지만 정기적인 리팩토링은 문제를 곪게 하므로 수시로 하는 것을 지향하도록 하자.
- 오래 걸리는 리팩터링
    - 기본적으로 리팩터링은 길어야 몇 시간으로 끝난다. 하지만 대규모 리팩토링이 존재할 수 있다. 이 때 팀 전체가 리팩터링을 매달리기 보다 몇 주에 걸쳐 조금씩 해결하는게 이상적이다. (기존의 코드가 깨지지 않아야 함을 강조)
- 코드 리뷰에 리팩터링 활용하기
    - 코드 리뷰는 기본적으로 지식을 전파하고 아이디어를 나누는데 효과적이다. 거기에 리팩터링을 접목하면 타인의 리뷰를 더 효과적으로 들을 수 있으며 떠오른 아이디어를 즉시 적용할 수 있어 더욱 좋다.
    - 코드 작성자 없이 검토하는 방식(풀요청 모델)보다 참석자가 참석하는 방식(짝 프로그래밍)에서 효과적이다.
- 관리자에게는 뭐라고 말해야 할까?
    - 리팩터링의 긍정적인 효과를 이미 알고 있는 관리자의 경우는 주저없이 리팩터링 하면 된다.
    - 관리자가 리팩터링에 대해 회의적인 경우는 걍 굳이 리팩터링한다고 설명하지 말고 하면 된다. 어차피 봐도 모른다. 개발하는건 자신이니 훨씬 생산적인 일을 결정하고 하도록 하자.
- 리팩터링하지 말아야 할 때
    - 코드가 지저분해도 굳이 수정해야할 필요가 없다면 하지말자.
    - 리팩터링하는 것보다 처음부터 새로 작성하는게 쉬우면 그냥 새로 작성해라. 단 해당 결정은 직접 해보기 전에는 결단하기 어려울 수 있다. 이 부분은 알아서 하자.(?)

2.5 리팩터링시 고려해야할 문제
- 새 기능 개발 속도 저하: 많은 사람이 리팩터링으로 개발이 늦어진다고 하지만 장기적으로 볼 때 전혀 그렇지 않다. 리팩토링의 목표는 어디까지나 개발 속도를 높여서 적은 노력으로 더 많은 가치를 창출하는 것이다.
- 코드 소유권: 코드의 권한은 엄격히 관리하는 것보다 느슨히 다루는 것이 좋다.
- 브랜치: 독립적인 브랜치가 개발되는 기간이 길어질 수록 머지와 통합이 어려워진다. 브랜치의 통합주기는 짧으면 짧을 수록 좋다. 지속적 통합CI를 통해 최대한 통합주기를 짧게 줄영 브랜치의 복잡돌르 줄이자.
- 테스팅: 리팩터링의 기본은 겉보기에 동작이 똑같이 유지된다는 것이고 이를 위해 자가 테스트 코드를 마련해야한다. 물론 테스트 코드를 만드는 것은 리팩토링을 넘어 새 기능 추가를 훨씬 안전하게 해주는 장치가 될 수도 있고 버그를 발견하는데 일등공신이 될 수 있다.
- 레거시 코드: 테스트코드가 없는 비대하고 복잡한 코드를 리팩터링 하는 것은 쉽지 않다. 처음 만들 때 잘 만들도록 하자..
- 데이터 베이스: 이 부분은 자바책의 잔재인가..

2.6 리팩터링, 아키텍처, 애그니(YAGNI)
처음부터 완벽한 아키텍처를 구사하는 것은 불가능에 가깝다. 때문에 유연적으로 상황에 대응하는 아키텍처를 지향하는 것이 옳다. 유연적인 대응은 온갖 상황에 다 대응한단 뜻이 아니라 변화에 대해 추측하지 않고, 현재까지 파악한 요구사항만 구축한 것에서 앞으로의 요구사항에 따라 그에 맞게 리팩터링해서 바꾸는 것을 말한다. 이런 식의 설계 방식을 간결한 설계, 점진적 설계, YAGNI(You Aren't Going to Need It)등으로 부른다. 중요한 것은 아키텍처를 전혀 고려하지 말라는 뜻이 아니며 나중에 문제를 더 기이 이해하게 됐을 때 처리할 경우 훨씬 효율적이고 기능이 잘 구사될 수 있기 때문이다.

2.7 리팩터링과 소프트웨어 개발 프로세스
> 자가 테스트 코드와 리팩터링을 묶어서 `테스트 주도 개발TDD`라고 한다.
- 자가 테스트 코드, 지속적 통합, 리팩터링 이라는 세 기법은 서로 강력한 상승 효과를 발휘한다.
- 물론 어떠한 접근법이든지 충분한 연습과 실력이 뒷받침돼야 한다.

2.8 리팩터링과 성능
대부분 프로그램은 전체 코드 중 극히 일부에서 성능이 저하되며 따라서 코드 저체를 고르게 최적화하면 결국 그 중 90%는 효과가 거의 없는 시간 낭비를 하게 된다. 때문에 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중하자. 그러다 성능 최적화 단계가 되면 그 때 최적화를 하면 된다. 

2.9 리팩터링의 유래
저자의 리팩터링 경험담. 나도 옆에서 깔끔한 코드 만드는 걸 직접 보게 되면 좋을텐데..

2.10 리팩터링 자동화
인텔리제이, 이클립스 등에서 리팩터링을 개발도구가 대신 해주기도 한다. 물론 이런 기능을 사용하려고 해도 기법을 알고 있어야 하며 직접 할 수 있어야 도움이 된다.

2.11 더 알고 싶다면
다양한 리팩터링 관련 서적 소개!
- 리팩터링 워크북(윌리엄 웨이크.2006): 연습할 수 있는 다양한 예제
- 패턴을 활용한 리팩터링(조슈아 케리에프스카.2011): 디자인 패턴과 접목
- 리팩토링 데이터베이스(스캇 엠블러, 프라모드 사달게.2007): 특정분야 관련
- 리팩토링 HTML(엘리엇 러스티 해롤드.2009): 특정분야 관련
- 레거시 코드 활용 전략(마이클 페더스.2018): 테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링 하는 법
